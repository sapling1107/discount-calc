<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta property="og:title" content="折扣計算器">
  <meta property="og:description" content="輸入原價、特價或折扣率，任兩個即可自動算出第三個。支援多行與折數提示！">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://sapling1107.github.io/discount-calc/">
  <meta property="og:image" content="https://sapling1107.github.io/discount-calc/og-image.png">
  <!-- 這行讓手機不要縮小整個網頁 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>折扣計算器</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif;
      padding: 20px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      max-width: 760px;
    }
    th, td {
      border: 1px solid #aaa;
      padding: 8px;
      text-align: center;
    }
    input {
      width: 110px;
      text-align: right;
    }
    button {
      margin-top: 10px;
      margin-right: 6px;
    }

    /* 手機版優化 */
    @media (max-width: 600px) {
      body { padding: 10px; }
      table { font-size: 14px; }
      th, td { padding: 6px; }
      input { width: 100%; box-sizing: border-box; font-size: 16px; }
      h2 { font-size: 18px; }
      button { font-size: 14px; padding: 6px 10px; }
    }
  </style>
</head>
<body>
  <h2>折扣計算器（三欄位互算，多行版）</h2>

  <table id="calcTable">
    <thead>
      <tr>
        <th>原價</th>
        <th>特價</th>
        <th>折扣率（可輸入 85 或 0.85）</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><input type="number" step="0.01" min="0"></td>
        <td><input type="number" step="0.01" min="0"></td>
        <td><input type="number" step="0.01" min="0"></td>
      </tr>
    </tbody>
  </table>

  <button onclick="addRow()">新增一行</button>
  <button onclick="clearAll()">清空所有行</button>

  <script>
    const has = v => !Number.isNaN(v);

    // 折扣輸入轉百分比（0.85 -> 85；85 -> 85）
    function toPercent(val) {
      if (!has(val)) return NaN;
      if (val <= 1.5) return val * 100;
      return val;
    }
    // 折扣輸入轉比例（85 -> 0.85；0.85 -> 0.85）
    function toRatio(val) {
      if (!has(val)) return NaN;
      if (val <= 1.5) return val;
      return val / 100;
    }

    function scheduleRecalc(input) {
      const row = input.closest("tr");
      // 記錄最後編輯欄位（0: 原價, 1: 特價, 2: 折扣）
      row.dataset.lastEdited = [...row.querySelectorAll("input")].indexOf(input);

      // debounce：避免輸入過程被打斷
      clearTimeout(row._timer);
      row._timer = setTimeout(() => recalcRow(row), 300);
    }

function recalcRow(row) {
  const inputs = row.querySelectorAll("input");
  let original = parseFloat(inputs[0].value);
  let sale     = parseFloat(inputs[1].value);
  let discRaw  = parseFloat(inputs[2].value);

  const has = v => !Number.isNaN(v);
  const filled = [has(original), has(sale), has(discRaw)].filter(Boolean).length;
  if (filled < 2) return;
  if (has(original) && original === 0) return;

  const last = parseInt(row.dataset.lastEdited ?? "0", 10);
  const toPercent = v => !has(v) ? NaN : (v <= 1.5 ? v * 100 : v);
  const toRatio   = v => !has(v) ? NaN : (v <= 1.5 ? v       : v / 100);

  if (filled === 3) {
    if (last === 2) { // 折扣最後改：用原價×折扣覆寫特價
      sale = original * toRatio(discRaw);
      inputs[1].value = sale.toFixed(2);
    } else if (last === 1) { // 特價最後改：回算折扣
      inputs[2].value = ((sale / original) * 100).toFixed(2);
    } else { // 原價最後改：用折扣算特價
      sale = original * toRatio(discRaw);
      inputs[1].value = sale.toFixed(2);
    }
  } else {
    // 只有兩格：補第三格
    if (has(original) && has(sale) && !has(discRaw)) {
      inputs[2].value = ((sale / original) * 100).toFixed(2);
    } else if (has(original) && !has(sale) && has(discRaw)) {
      sale = original * toRatio(discRaw);
      inputs[1].value = sale.toFixed(2);
      inputs[2].value = toPercent(discRaw).toFixed(2);
    } else if (!has(original) && has(sale) && has(discRaw)) {
      original = sale / toRatio(discRaw);
      inputs[0].value = original.toFixed(2);
      inputs[2].value = toPercent(discRaw).toFixed(2);
    }
  }
}

    // 綁定初始列事件
    function bindRow(row) {
      const inputs = row.querySelectorAll("input");
      inputs.forEach(inp => {
        inp.addEventListener("input", () => scheduleRecalc(inp));
        inp.addEventListener("focus", () => { row.dataset.lastEdited = [...inputs].indexOf(inp); });
      });
    }
    bindRow(document.querySelector("#calcTable tbody tr"));

function addRow() {
  const tbody = document.querySelector("#calcTable tbody");
  const tr = document.createElement("tr");
  for (let i = 0; i < 3; i++) {
    const td = document.createElement("td");
    const input = document.createElement("input");
    input.type = "number"; input.step = "0.01"; input.min = "0";
    td.appendChild(input); tr.appendChild(td);
  }
  tbody.appendChild(tr);
  bindRow(tr);
}

    function clearAll() {
      const tbody = document.querySelector("#calcTable tbody");
      tbody.innerHTML = "";
      addRow();
    }
  </script>
</body>
</html>
